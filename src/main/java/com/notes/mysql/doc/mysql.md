# mysql

## 基础架构
#### mysql 基本架构示意图
![架构](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

#### 大体来说mysql分为 server层 和 数据存储引擎俩部分
###  1. 连接器 
   负责和客户端建立连接、获取权限、保持连接以及管理连接
   建立连接、认证身份、确认权限（从权限表中查询拥有的权限，之后所有的操作都会依赖此时查询到的权限进行判定，期间管理员对此用户的权限
   进行修改也并不会影响已经建立的连接，当重新连接时修改的权限才会生效）
   连接 默认空闲超时时长为8小时
   - 长连接：数据库建立连接后，如果客户端持续有请求，则一直使用同一个连接。
   - 短连接：每次执行完很少的几次查询就断开连接，下次查询再重新建立连接。  
    尽量使用长连接以减少连接操作，但是时间长了会导致mysql服务占用内存涨的特别块，这是因为mysql在执行过程中使用的临时内存是管理在连接
     对象里的，这些资源会在连接断开的时候才释放，**_所以如果长期积累下来就可能导致内存占用过大，最终(OOM)，从现象上看就是mysql异常重启了。_**
   
**问题解决：**   
   1】 定期断开重连  
   2】 mysql5.7以及更高版本 可以在每执行一个较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个
   过程不需要重连和重新做权限认证，只是将连接恢复到刚开始连接的时候。
     
    
### 2. 查询缓存  
执行sql要先查询缓存，缓存查询不到再执行后续操作，缓存以sql作为key查询结果作为value进行存储，只要对一个表有更新操作这个标上的缓存就会全部失效
mysql8.0之前提供了按需使用的策略，8.0之后该功能模块已被移除。

### 3.分析器
如果没有命中缓存就会开始真正执行sql语句了，首先要对sql语句进行解析
- 识别关键字 如表名、列名
- 语法分析 该sql语句是否符合mysql语法规范
### 4.优化器
如果sql语句没有问题 接下来就会对语句进行优化 例如：倘若存在索引需要确认使用那个索引；或者在一条语句中有多个表关联，决定各个表的连接顺序。
### 5.执行器
sql优化完毕就开始真正执行了，首先判断有没有对操作的表有权限

## 日志系统
### redo log
+ 属于innodb独有 是存储层的日志 记录物理页的修改
+ redo log 是固定大小、循环读写的
  > 1、write pos 当前记录的位置 要写的位置  
  > 2、提供了 crash safe 能力 （即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。）
  > 3、check point  检查的点位 当前要擦除的位置
  ![position](https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png)
  
### binlog
+ binlog 是server层的日志 是记录逻辑修改的 分为statement、row模式 row模式下会记录修改之前和之后的数据 所以日志会变得很大
+ binlog是追加读写的 只要磁盘够大 会一直写下去

### sql执行流程
    update Table set row = row +1 where id = 2
- 1、执行器先找 id = 2 这一行数据。id是主键 引擎直接使用树搜索找到这一行。如果id = 2 这一行所在的数据页本来就缓存在内存中，就直接
返回给执行器；否则先要从磁盘读入内存，然后再返回。
- 2、执行器拿到引擎给的数据 将其加1 得到新的一行数据 再调用引擎接口将数据写回
- 3、引擎将这行新数据更新到内存中(后续异步刷到磁盘上) 同时将这个更新操作记录到redo log里面，此时 redo log处于prepare状态。然后告知执行器执行完了，可以
随时提交事物
- 4、执行器生成这个操作的binlog，并将把binlog写入磁盘
- 5、执行器调用引擎的提交事物接口，引擎把刚刚写入的redo log改成提交(commit)状态，更新完成。
    ![流程图](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

### 总结   
1、redo log 拆成俩个状态 prepare、commit，这就是俩阶段提交，保证俩个日志的一致性 我们常用的分布式事物也是这样做的。俩阶段提交
是跨服务维持数据逻辑一致性时常用的一种解决方案  
2、redo log 用于保证 crash-safe能力。        
（1）innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。   
（2）sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。    

## 事物
+ （Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）
### 隔离性
#### 多个事物同时执行的时候 可能出现脏读、不可重复读、幻读等问题，为了解决这些问题就有了隔离级别的概念
#### sql标准的隔离级别包括：读未提交(read uncommitted)、读已提交(read committed)、可重复读(repeatable read)、串行化
+ 读未提交是指一个事物还没提交时，它的变更就能被别的事物看到
+ 读已提交是指一个事物提交之后，它的变更才能被别的事物看到
+ 可重复读是指，一个事物执行过程中看到的数据，总是跟这个事物在启动时看到的数据一致。当然在可重复读隔离级别下，未提交变更对其它事物也是不可见的。
+ 串行化是指，对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事物必须等前一个事物执行完成，才能继续执行。
#### 事物隔离的实现
##### 通过回滚日志实现 同一条数据在数据库中可以存在多个版本，就是数据库的多版本控制（mvcc）当系统里没有比这个回滚日志更早的read-view存在时回滚日志会被删除（避免使用长事物）



